#!/bin/bash

# --- Configuration ---
MAX_DURATION_SECONDS=140
MAX_FILE_SIZE_MB=512
TARGET_FILE_SIZE_BYTES=$((MAX_FILE_SIZE_MB * 1024 * 1024))
# Allocate 95% of the total size for video stream to leave room for audio and container overhead
VIDEO_SIZE_PERCENTAGE=0.95 

# Function to display error and exit
function die {
    echo -e "\n[ERROR] $1" >&2
    exit 1
}

# Check for necessary tools (ffprobe and ffmpeg)
command -v ffmpeg >/dev/null 2>&1 || die "ffmpeg is required but not found. Please install it."
command -v ffprobe >/dev/null 2>&1 || die "ffprobe is required but not found. Please install it."

echo "--- X (Twitter) Video Converter (Free User Requirements) ---"

# --- Get Input File ---
if [ -z "$1" ]; then
    read -p "Enter the full path to the video file you want to process: " INPUT_FILE
else
    INPUT_FILE="$1"
fi

# Validate input file existence
[ -f "$INPUT_FILE" ] || die "Input file not found at: $INPUT_FILE"

OUTPUT_FILE="$(dirname "$INPUT_FILE")/x_$(basename "$INPUT_FILE")"

# --- 1. Get Video Duration and Check Trimming Need ---

echo -e "\nChecking video duration..."

# Get duration in seconds using ffprobe
DURATION_SECONDS=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$INPUT_FILE" | awk '{print int($1)}')

if [ -z "$DURATION_SECONDS" ]; then
    die "Could not determine video duration. Is the file corrupted or an unsupported format?"
fi

# Set the final duration for bitrate calculation
FINAL_DURATION_SECONDS=$DURATION_SECONDS
TRIM_FLAG=""
TRIM_MESSAGE="Duration is within the $MAX_DURATION_SECONDS second limit."

if (( DURATION_SECONDS > MAX_DURATION_SECONDS )); then
    echo "  [INFO] Original duration: $DURATION_SECONDS seconds."
    echo "  [INFO] Video is longer than the $MAX_DURATION_SECONDS second limit."
    
    # Set the trimming flag to cut the first 140 seconds
    TRIM_FLAG="-ss 0 -to $MAX_DURATION_SECONDS"
    FINAL_DURATION_SECONDS=$MAX_DURATION_SECONDS
    TRIM_MESSAGE="Video will be trimmed to the first $MAX_DURATION_SECONDS seconds."
else
    echo "  [INFO] Duration: $DURATION_SECONDS seconds. $TRIM_MESSAGE"
fi

# --- 2. Calculate Required Bitrate for 512 MB Target ---

# Bitrate calculation (bits per second) = (Target Bytes * 8 * 0.95) / Final Duration
# We subtract a small amount (5%) for audio and container overhead.

# Calculate the video stream bitrate (in bps)
TARGET_VIDEO_BITRATE_BPS=$(echo "scale=0; ($TARGET_FILE_SIZE_BYTES * 8 * $VIDEO_SIZE_PERCENTAGE) / $FINAL_DURATION_SECONDS" | bc)

# Convert to Mbps for better logging
TARGET_VIDEO_BITRATE_MBPS=$(echo "scale=2; $TARGET_VIDEO_BITRATE_BPS / 1000000" | bc)

# Check if the calculated bitrate is sensible (e.g., less than 50 Mbps)
if (( TARGET_VIDEO_BITRATE_BPS > 50000000 )); then
    echo "  [WARNING] Calculated bitrate is very high ($TARGET_VIDEO_BITRATE_MBPS Mbps)."
    echo "  [WARNING] Capping video bitrate at 10 Mbps for better compatibility and quality consistency."
    TARGET_VIDEO_BITRATE_BPS=10000000
    TARGET_VIDEO_BITRATE_MBPS=10.0
fi

echo -e "\n--- Processing Details ---"
echo "  Input File: $INPUT_FILE"
echo "  Output File: $OUTPUT_FILE"
echo "  $TRIM_MESSAGE"
echo "  Final Duration Used for Calculation: $FINAL_DURATION_SECONDS seconds"
echo "  Target File Size: $MAX_FILE_SIZE_MB MB"
echo "  Target Video Bitrate: ${TARGET_VIDEO_BITRATE_MBPS} Mbps"
echo -e "--------------------------\n"

# --- 3. Run FFmpeg Conversion and Compression ---

echo "Starting FFmpeg conversion..."
echo "This may take a while depending on your video length and speed."

# FFmpeg command structure:
# $TRIM_FLAG: Handles the trimming if required.
# -i "$INPUT_FILE": Specifies the input file.
# -c:v libx264: Sets the video codec to H.264.
# -preset medium: Controls the encoding speed/compression ratio (medium is a good balance).
# -b:v ${TARGET_VIDEO_BITRATE_BPS}: Sets the target video bitrate.
# -pix_fmt yuv420p: Ensures compatibility across all players (critical for MP4/H.264).
# -c:a aac: Sets the audio codec to AAC.
# -b:a 128k: Sets the audio bitrate (128 kbps is standard quality).
# -movflags +faststart: Optimizes the file for web streaming.
# -y: Overwrite output file if it exists.

ffmpeg $TRIM_FLAG \
       -i "$INPUT_FILE" \
       -c:v libx264 \
       -preset medium \
       -b:v ${TARGET_VIDEO_BITRATE_BPS} \
       -pix_fmt yuv420p \
       -c:a aac \
       -b:a 128k \
       -movflags +faststart \
       -y \
       "$OUTPUT_FILE"

# --- Conclusion ---

if [ $? -eq 0 ]; then
    echo -e "\n[SUCCESS] Video processed successfully!"
    echo "The file is saved as: $OUTPUT_FILE"
    
    FINAL_SIZE_MB=$(du -h "$OUTPUT_FILE" | awk '{print $1}')
    echo "Final file size: $FINAL_SIZE_MB (Should be close to $MAX_FILE_SIZE_MB MB)"
    echo "The video is now optimized for X (Twitter) free user requirements."
else
    die "FFmpeg process failed. Check the output above for errors."
fi

# Clean up temporary files (if any were created in more complex versions)
# No need here as we use direct pipe/output.
exit 0
